diff --git a/LICENSE b/LICENSE
index 1ace9a3..44b6b84 100644
--- a/LICENSE
+++ b/LICENSE
@@ -21,4 +21,3 @@ NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-
diff --git a/Makefile b/Makefile
index 62fd0f8..5fd9d13 100644
--- a/Makefile
+++ b/Makefile
@@ -32,7 +32,7 @@ OBJS = \
 
 # riscv64-unknown-elf- or riscv64-linux-gnu-
 # perhaps in /opt/riscv/bin
-#TOOLPREFIX = 
+#TOOLPREFIX =
 
 # Try to infer the correct TOOLPREFIX if not set
 ifndef TOOLPREFIX
@@ -81,7 +81,7 @@ endif
 LDFLAGS = -z max-page-size=4096
 
 $K/kernel: $(OBJS) $K/kernel.ld $U/initcode
-	$(LD) $(LDFLAGS) -T $K/kernel.ld -o $K/kernel $(OBJS) 
+	$(LD) $(LDFLAGS) -T $K/kernel.ld -o $K/kernel $(OBJS)
 	$(OBJDUMP) -S $K/kernel > $K/kernel.asm
 	$(OBJDUMP) -t $K/kernel | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > $K/kernel.sym
 
@@ -139,13 +139,15 @@ UPROGS=\
 	$U/_grind\
 	$U/_wc\
 	$U/_zombie\
+	$U/_dummyproc\
+	$U/_testprocinfo\
 
 fs.img: mkfs/mkfs README $(UPROGS)
 	mkfs/mkfs fs.img README $(UPROGS)
 
 -include kernel/*.d user/*.d
 
-clean: 
+clean:
 	rm -f *.tex *.dvi *.idx *.aux *.log *.ind *.ilg \
 	*/*.o */*.d */*.asm */*.sym \
 	$U/initcode $U/initcode.out $K/kernel fs.img \
@@ -160,7 +162,7 @@ QEMUGDB = $(shell if $(QEMU) -help | grep -q '^-gdb'; \
 	then echo "-gdb tcp::$(GDBPORT)"; \
 	else echo "-s -p $(GDBPORT)"; fi)
 ifndef CPUS
-CPUS := 3
+CPUS := 1
 endif
 
 QEMUOPTS = -machine virt -bios none -kernel $K/kernel -m 128M -smp $(CPUS) -nographic
@@ -177,4 +179,3 @@ qemu: $K/kernel fs.img
 qemu-gdb: $K/kernel .gdbinit fs.img
 	@echo "*** Now run 'gdb' in another window." 1>&2
 	$(QEMU) $(QEMUOPTS) -S $(QEMUGDB)
-
diff --git a/kernel/bio.c b/kernel/bio.c
index 60d91a6..5207569 100644
--- a/kernel/bio.c
+++ b/kernel/bio.c
@@ -132,7 +132,7 @@ brelse(struct buf *b)
     bcache.head.next->prev = b;
     bcache.head.next = b;
   }
-  
+
   release(&bcache.lock);
 }
 
@@ -149,5 +149,3 @@ bunpin(struct buf *b) {
   b->refcnt--;
   release(&bcache.lock);
 }
-
-
diff --git a/kernel/buf.h b/kernel/buf.h
index 4616e9e..aafabea 100644
--- a/kernel/buf.h
+++ b/kernel/buf.h
@@ -9,4 +9,3 @@ struct buf {
   struct buf *next;
   uchar data[BSIZE];
 };
-
diff --git a/kernel/console.c b/kernel/console.c
index 05dc526..cb3fdc3 100644
--- a/kernel/console.c
+++ b/kernel/console.c
@@ -43,7 +43,7 @@ consputc(int c)
 
 struct {
   struct spinlock lock;
-  
+
   // input
 #define INPUT_BUF_SIZE 128
   char buf[INPUT_BUF_SIZE];
@@ -174,7 +174,7 @@ consoleintr(int c)
     }
     break;
   }
-  
+
   release(&cons.lock);
 }
 
diff --git a/kernel/defs.h b/kernel/defs.h
index d1b6bb9..971764b 100644
--- a/kernel/defs.h
+++ b/kernel/defs.h
@@ -106,6 +106,7 @@ void            yield(void);
 int             either_copyout(int user_dst, uint64 dst, void *src, uint64 len);
 int             either_copyin(void *dst, int user_src, uint64 src, uint64 len);
 void            procdump(void);
+int             send_current_pstat(uint64 addr);
 
 // swtch.S
 void            swtch(struct context*, struct context*);
diff --git a/kernel/exec.c b/kernel/exec.c
index e18bbb6..794a10d 100644
--- a/kernel/exec.c
+++ b/kernel/exec.c
@@ -119,7 +119,7 @@ exec(char *path, char **argv)
     if(*s == '/')
       last = s+1;
   safestrcpy(p->name, last, sizeof(p->name));
-    
+
   // Commit to the user image.
   oldpagetable = p->pagetable;
   p->pagetable = pagetable;
@@ -161,6 +161,6 @@ loadseg(pagetable_t pagetable, uint64 va, struct inode *ip, uint offset, uint sz
     if(readi(ip, 0, (uint64)pa, offset+i, n) != n)
       return -1;
   }
-  
+
   return 0;
 }
diff --git a/kernel/file.c b/kernel/file.c
index 25fa226..6968af5 100644
--- a/kernel/file.c
+++ b/kernel/file.c
@@ -89,7 +89,7 @@ filestat(struct file *f, uint64 addr)
 {
   struct proc *p = myproc();
   struct stat st;
-  
+
   if(f->type == FD_INODE || f->type == FD_DEVICE){
     ilock(f->ip);
     stati(f->ip, &st);
@@ -179,4 +179,3 @@ filewrite(struct file *f, uint64 addr, int n)
 
   return ret;
 }
-
diff --git a/kernel/fs.c b/kernel/fs.c
index c6bab15..e73bb50 100644
--- a/kernel/fs.c
+++ b/kernel/fs.c
@@ -24,7 +24,7 @@
 #define min(a, b) ((a) < (b) ? (a) : (b))
 // there should be one superblock per disk device, but we run with
 // only one device
-struct superblock sb; 
+struct superblock sb;
 
 // Read the super block.
 static void
@@ -182,7 +182,7 @@ void
 iinit()
 {
   int i = 0;
-  
+
   initlock(&itable.lock, "itable");
   for(i = 0; i < NINODE; i++) {
     initsleeplock(&itable.inode[i].lock, "inode");
diff --git a/kernel/fs.h b/kernel/fs.h
index 139dcc9..365b0ef 100644
--- a/kernel/fs.h
+++ b/kernel/fs.h
@@ -57,4 +57,3 @@ struct dirent {
   ushort inum;
   char name[DIRSIZ];
 };
-
diff --git a/kernel/kernelvec.S b/kernel/kernelvec.S
index a18ecbb..c47a047 100644
--- a/kernel/kernelvec.S
+++ b/kernel/kernelvec.S
@@ -73,7 +73,7 @@ timervec:
         # scratch[0,8,16] : register save area.
         # scratch[24] : address of CLINT's MTIMECMP register.
         # scratch[32] : desired interval between interrupts.
-        
+
         csrrw a0, mscratch, a0
         sd a1, 0(a0)
         sd a2, 8(a0)
diff --git a/kernel/log.c b/kernel/log.c
index 5b58306..67aa855 100644
--- a/kernel/log.c
+++ b/kernel/log.c
@@ -233,4 +233,3 @@ log_write(struct buf *b)
   }
   release(&log.lock);
 }
-
diff --git a/kernel/main.c b/kernel/main.c
index f0d3171..184fa96 100644
--- a/kernel/main.c
+++ b/kernel/main.c
@@ -41,5 +41,5 @@ main()
     plicinithart();   // ask PLIC for device interrupts
   }
 
-  scheduler();        
+  scheduler();
 }
diff --git a/kernel/memlayout.h b/kernel/memlayout.h
index cac3cb1..c43131e 100644
--- a/kernel/memlayout.h
+++ b/kernel/memlayout.h
@@ -6,8 +6,8 @@
 // 00001000 -- boot ROM, provided by qemu
 // 02000000 -- CLINT
 // 0C000000 -- PLIC
-// 10000000 -- uart0 
-// 10001000 -- virtio disk 
+// 10000000 -- uart0
+// 10001000 -- virtio disk
 // 80000000 -- boot ROM jumps here in machine mode
 //             -kernel loads the kernel here
 // unused RAM after 80000000.
diff --git a/kernel/param.h b/kernel/param.h
index 6624bff..862968f 100644
--- a/kernel/param.h
+++ b/kernel/param.h
@@ -11,3 +11,17 @@
 #define NBUF         (MAXOPBLOCKS*3)  // size of disk block cache
 #define FSSIZE       2000  // size of file system in blocks
 #define MAXPATH      128   // maximum file path name
+
+
+
+#define TIME_LIMIT_0        2
+#define TIME_LIMIT_1        4
+#define WAIT_THRESH         6
+#define DEFAULT_TICKETS     10
+
+
+// #define LOG_RAW 0
+// #define LOG_PROMO 1
+// #define LOG_DEMO 1
+// #define LOG_BOOST 0
+// #define LOG_LOTTERY 0
diff --git a/kernel/plic.c b/kernel/plic.c
index 4175db9..84d60ed 100644
--- a/kernel/plic.c
+++ b/kernel/plic.c
@@ -20,7 +20,7 @@ void
 plicinithart(void)
 {
   int hart = cpuid();
-  
+
   // set enable bits for this hart's S-mode
   // for the uart and virtio disk.
   *(uint32*)PLIC_SENABLE(hart) = (1 << UART0_IRQ) | (1 << VIRTIO0_IRQ);
diff --git a/kernel/proc.c b/kernel/proc.c
index 58a8a0b..e54f99a 100644
--- a/kernel/proc.c
+++ b/kernel/proc.c
@@ -5,6 +5,26 @@
 #include "spinlock.h"
 #include "proc.h"
 #include "defs.h"
+#include "pstat.h"
+#include "random.h"
+
+#define BLACK_COLOR "\033[30m"
+#define RED_COLOR "\033[31m"
+#define GREEN_COLOR "\033[32m"
+#define YELLOW_COLOR "\033[33m"
+#define BLUE_COLOR "\033[34m"
+#define MAGENTA_COLOR "\033[35m"
+#define CYAN_COLOR "\033[36m"
+#define WHITE_COLOR "\033[37m"
+#define RESET_COLOR "\033[0m"
+
+
+int LOG_RAW = 0;
+int LOG_PROMO = 0;
+int LOG_DEMO = 0;
+int LOG_BOOST = 0;
+int LOG_LOTTERY = 0;
+
 
 struct cpu cpus[NCPU];
 
@@ -33,7 +53,7 @@ void
 proc_mapstacks(pagetable_t kpgtbl)
 {
   struct proc *p;
-  
+
   for(p = proc; p < &proc[NPROC]; p++) {
     char *pa = kalloc();
     if(pa == 0)
@@ -48,7 +68,7 @@ void
 procinit(void)
 {
   struct proc *p;
-  
+
   initlock(&pid_lock, "nextpid");
   initlock(&wait_lock, "wait_lock");
   for(p = proc; p < &proc[NPROC]; p++) {
@@ -93,7 +113,7 @@ int
 allocpid()
 {
   int pid;
-  
+
   acquire(&pid_lock);
   pid = nextpid;
   nextpid = nextpid + 1;
@@ -125,6 +145,16 @@ found:
   p->pid = allocpid();
   p->state = USED;
 
+  // initialize scheduling related parameters
+  p->original_tickets = DEFAULT_TICKETS;
+  p->current_tickets = DEFAULT_TICKETS;
+  p->inQ = 0;
+  p->running_time = 0;
+  p->waiting_time = 0;
+  p->times_scheduled = 0;
+  p->queue_ticks[0] = p->queue_ticks[1] = 0;
+  p->last_queue_tick_stamps[0] = p->last_queue_tick_stamps[1] = ticks;
+
   // Allocate a trapframe page.
   if((p->trapframe = (struct trapframe *)kalloc()) == 0){
     freeproc(p);
@@ -236,7 +266,7 @@ userinit(void)
 
   p = allocproc();
   initproc = p;
-  
+
   // allocate one user page and copy initcode's instructions
   // and data into it.
   uvmfirst(p->pagetable, initcode, sizeof(initcode));
@@ -320,6 +350,10 @@ fork(void)
 
   acquire(&np->lock);
   np->state = RUNNABLE;
+  // Setting the tickets of child
+  // as same of the original tickets of parent
+  np->original_tickets = p->original_tickets;
+  np->current_tickets = p->original_tickets;
   release(&np->lock);
 
   return pid;
@@ -372,7 +406,7 @@ exit(int status)
 
   // Parent might be sleeping in wait().
   wakeup(p->parent);
-  
+
   acquire(&p->lock);
 
   p->xstate = status;
@@ -428,12 +462,13 @@ wait(uint64 addr)
       release(&wait_lock);
       return -1;
     }
-    
+
     // Wait for a child to exit.
     sleep(p, &wait_lock);  //DOC: wait-sleep
   }
 }
 
+
 // Per-CPU process scheduler.
 // Each CPU calls scheduler() after setting itself up.
 // Scheduler never returns.  It loops, doing:
@@ -444,7 +479,7 @@ wait(uint64 addr)
 void
 scheduler(void)
 {
-  struct proc *p;
+  // struct proc *p;
   struct cpu *c = mycpu();
 
   c->proc = 0;
@@ -454,13 +489,88 @@ scheduler(void)
     // processes are waiting.
     intr_on();
 
-    for(p = proc; p < &proc[NPROC]; p++) {
+    while(1){
+      // Lottery Scheduling
+      int process_count_q0 = 0;
+      int eligible_count = 0;
+      int eligible_proc_indices[NPROC], cumulative_ticket_sums[NPROC];
+      int last_cumulative_sum = 0;
+
+      // find eligible processes after looping through all
+      for(int i=0; i<NPROC; i++) {
+        struct proc *p = &proc[i];
+        acquire(&p->lock);
+        if(p->state == RUNNABLE && p->inQ == 0){
+          process_count_q0++;
+          if(p->current_tickets > 0){
+            eligible_proc_indices[eligible_count] = i;
+            cumulative_ticket_sums[eligible_count] = last_cumulative_sum + p->current_tickets;
+            last_cumulative_sum = cumulative_ticket_sums[eligible_count];
+            eligible_count++;
+          }
+        }
+        release(&p->lock);
+      }
+
+      // break from while if no eligible process found in this queue
+      if(process_count_q0 == 0){
+        // printf("No processes in q0...\n");
+        // now move on to the next RR queue
+        break;  // from the while
+      }
+
+      // if all have used up their all tickets
+      // reinitialize their tickets and
+      // continue to next lottery
+      if(eligible_count == 0){
+        for(int i=0; i<NPROC; i++) {
+          struct proc *p = &proc[i];
+          acquire(&p->lock);
+          p->current_tickets = p->original_tickets;
+          release(&p->lock);
+        }
+        continue;  // from the while
+      }
+
+      // perform lottery and select one process
+      int random_num = get_random_number(last_cumulative_sum);
+      if(LOG_RAW){
+        printf("\nlast_cumulative_sum = %d\n", last_cumulative_sum);
+        printf("\nrandom = %d\n", random_num);
+      }
+      int selected_index = -1;
+      int prev = 0;
+      for(int i=0; i<eligible_count; i++){
+        if(random_num > prev && random_num <= cumulative_ticket_sums[i]){
+          // found
+          selected_index = eligible_proc_indices[i];
+          break;
+        }
+        prev = cumulative_ticket_sums[i];
+      }
+
+      // take the selected process
+      struct proc* p = &proc[selected_index];
+
+      if(LOG_LOTTERY){
+        printf(BLUE_COLOR "\nLOTTERY: Process %d (%s) won in queue 0 with tickets %d\n" RESET_COLOR, p->pid, p->name, p->current_tickets);
+      }
+
+      p->times_scheduled++;
+      p->waiting_time = 0;
+      p->current_tickets--;
+
+      uint starting_tick = ticks;
+
+      // keep running it for TIME_LIMIT_0
       acquire(&p->lock);
-      if(p->state == RUNNABLE) {
+      while(p->state == RUNNABLE && p->running_time < TIME_LIMIT_0){
         // Switch to chosen process.  It is the process's job
         // to release its lock and then reacquire it
         // before jumping back to us.
         p->state = RUNNING;
+        p->running_time++;
+
         c->proc = p;
         swtch(&c->context, &p->context);
 
@@ -468,6 +578,109 @@ scheduler(void)
         // It should have changed its p->state before coming back.
         c->proc = 0;
       }
+
+      if(p->running_time == TIME_LIMIT_0){
+        // used up all ticks
+        if(LOG_DEMO){
+          printf(RED_COLOR "\nDEMO: Process %d (%s) ran for %d time ticks, demoted to queue 1\n" RESET_COLOR, p->pid, p->name, p->running_time);
+        }
+
+        p->queue_ticks[0] += (ticks - p->last_queue_tick_stamps[0]);
+
+        p->inQ = 1;
+        p->last_queue_tick_stamps[1] = ticks;
+
+      } else{
+        p->running_time = 0;
+      }
+      release(&p->lock);
+
+      for(int j=0; j<NPROC; j++) {
+        if(j != selected_index){
+          struct proc* p = &proc[j];
+          acquire(&p->lock);
+          if(p->state == RUNNABLE){
+            p->waiting_time += (ticks - starting_tick);
+            // Aging Mechanism
+            if(p->waiting_time >= WAIT_THRESH && p->inQ == 1){
+              p->inQ = 0;
+              if(LOG_BOOST){
+                printf(MAGENTA_COLOR "\nBOOST: Process %d (%s) waited for %d ticks, promoted to queue 0\n" RESET_COLOR, p->pid, p->name, WAIT_THRESH);
+              }
+            }
+          }
+          release(&p->lock);
+        }
+      }
+    }
+
+    // Checking q1 now
+    int i;
+    for(i=0; i<NPROC; i++){
+    // for(p = proc; p < &proc[NPROC]; p++) {
+      struct proc* p = &proc[i];
+      acquire(&p->lock);
+      if(p->state == RUNNABLE && p->inQ == 1) {
+
+        uint starting_tick = ticks;
+
+        // Round Robin Scheduling
+        p->times_scheduled++;
+        p->waiting_time = 0;
+        while(p->running_time < TIME_LIMIT_1 && p->state == RUNNABLE){
+          // Switch to chosen process.  It is the process's job
+          // to release its lock and then reacquire it
+          // before jumping back to us.
+          p->state = RUNNING;
+          p->running_time++;
+
+          c->proc = p;
+          swtch(&c->context, &p->context);
+
+          // Process is done running for now.
+          // It should have changed its p->state before coming back.
+          c->proc = 0;
+        }
+
+        if(p->running_time < TIME_LIMIT_1){
+          if(LOG_PROMO){
+            printf(GREEN_COLOR "\nPROMO: Process %d (%s) ran for %d time ticks, promoted to queue 0\n" RESET_COLOR, p->pid, p->name, p->running_time);
+          }
+
+          p->queue_ticks[1] += (ticks - p->last_queue_tick_stamps[1]);
+
+          p->inQ = 0;
+          p->last_queue_tick_stamps[0] = ticks;
+
+        } else{
+          p->running_time = 0;
+        }
+
+        for(int j=0; j<NPROC; j++) {
+          if(j != i){
+            struct proc* p = &proc[j];
+            acquire(&p->lock);
+            if(p->state == RUNNABLE){
+              p->waiting_time += (ticks - starting_tick);
+              // Aging Mechanism
+              if(p->waiting_time >= WAIT_THRESH && p->inQ == 1){
+                p->inQ = 0;
+                if(LOG_BOOST){
+                  printf(MAGENTA_COLOR "\nBOOST: Process %d (%s) waited for %d ticks, promoted to queue 0\n" RESET_COLOR, p->pid, p->name, WAIT_THRESH);
+                }
+              }
+            }
+            release(&p->lock);
+          }
+        }
+
+        // we are actually running only one process from the RR queue
+        // then we break from the RR queue loop
+        // due to the outer infinite loop, we will now essentially
+        // go back to checking the lottery queue again
+        release(&p->lock);
+        break;
+      }
       release(&p->lock);
     }
   }
@@ -541,7 +754,7 @@ void
 sleep(void *chan, struct spinlock *lk)
 {
   struct proc *p = myproc();
-  
+
   // Must acquire p->lock in order to
   // change p->state and then call sched.
   // Once we hold p->lock, we can be
@@ -620,7 +833,7 @@ int
 killed(struct proc *p)
 {
   int k;
-  
+
   acquire(&p->lock);
   k = p->killed;
   release(&p->lock);
@@ -686,3 +899,38 @@ procdump(void)
     printf("\n");
   }
 }
+
+
+int send_current_pstat(uint64 addr){
+  struct proc* curr_proc = myproc();
+  struct pstat curr_stat;
+
+  int i;
+  for(i=0; i<NPROC; i++){
+    struct proc p = proc[i];
+
+    acquire(&p.lock);
+    curr_stat.pid[i] = p.pid;
+    curr_stat.inuse[i] = (p.state == RUNNABLE || p.state == RUNNING);
+    curr_stat.inQ[i] = p.inQ;
+    curr_stat.waiting_time[i] = p.waiting_time;
+    curr_stat.running_time[i] = p.running_time;
+    curr_stat.times_scheduled[i] = p.times_scheduled;
+    curr_stat.tickets_original[i] = p.original_tickets;
+    curr_stat.tickets_current[i] = p.current_tickets;
+    curr_stat.queue_ticks[i][0] = p.queue_ticks[0];
+    if(p.inQ == 0){
+      curr_stat.queue_ticks[i][0] += (ticks - p.last_queue_tick_stamps[0]);
+    }
+    curr_stat.queue_ticks[i][1] = p.queue_ticks[1];
+    if(p.inQ == 1){
+      curr_stat.queue_ticks[i][1] += (ticks - p.last_queue_tick_stamps[1]);
+    }
+    release(&p.lock);
+  }
+
+  if(copyout(curr_proc->pagetable, addr, (char *)&curr_stat, sizeof(curr_stat)) < 0)
+    return -1;
+
+  return 0;
+}
diff --git a/kernel/proc.h b/kernel/proc.h
index d021857..62a970b 100644
--- a/kernel/proc.h
+++ b/kernel/proc.h
@@ -104,4 +104,16 @@ struct proc {
   struct file *ofile[NOFILE];  // Open files
   struct inode *cwd;           // Current directory
   char name[16];               // Process name (debugging)
+
+
+  uint original_tickets;
+
+  uint current_tickets;
+  uint inQ;               // 0 or 1
+  uint running_time;
+  uint waiting_time;
+  uint last_waiting_tick_stamp;
+  uint times_scheduled;
+  uint queue_ticks[2];
+  uint last_queue_tick_stamps[2];
 };
diff --git a/kernel/pstat.h b/kernel/pstat.h
new file mode 100644
index 0000000..e5d7ef5
--- /dev/null
+++ b/kernel/pstat.h
@@ -0,0 +1,19 @@
+#ifndef _PSTAT_H_
+#define _PSTAT_H_
+
+#include "param.h"
+#include "types.h"
+
+struct pstat {
+    int pid[NPROC];               // the process ID of each process
+    int inuse[NPROC];             // whether this slot of the process table is being used (1 or 0)
+    int inQ[NPROC];               // which queue the process is currently in
+    int waiting_time[NPROC];      // the time each process has spent waiting before being scheduled
+    int running_time[NPROC];      // Number of times the process was scheduled before its time slice was used
+    int times_scheduled[NPROC];   // the total number of times this process was scheduled
+    int tickets_original[NPROC];  // the number of tickets each process originally had
+    int tickets_current[NPROC];   // the number of tickets each process currently has
+    uint queue_ticks[NPROC][2];   // the total number of ticks each process has spent in each queue
+};
+
+#endif
diff --git a/kernel/random.h b/kernel/random.h
new file mode 100644
index 0000000..d072434
--- /dev/null
+++ b/kernel/random.h
@@ -0,0 +1,20 @@
+#include "types.h"
+
+// XOR-shift random number generator function
+
+// deterministic seed
+uint64 SEED = 111;
+
+// returns a random number
+// in the range [1,n]
+int get_random_number(int n) {
+  uint64 x = SEED;
+
+  x ^= x << 13;
+  x ^= x >> 17;
+  x ^= x << 5;
+
+  SEED = x;
+
+  return 1 + x%n;
+}
\ No newline at end of file
diff --git a/kernel/riscv.h b/kernel/riscv.h
index 20a01db..52eafba 100644
--- a/kernel/riscv.h
+++ b/kernel/riscv.h
@@ -25,7 +25,7 @@ r_mstatus()
   return x;
 }
 
-static inline void 
+static inline void
 w_mstatus(uint64 x)
 {
   asm volatile("csrw mstatus, %0" : : "r" (x));
@@ -34,7 +34,7 @@ w_mstatus(uint64 x)
 // machine exception program counter, holds the
 // instruction address to which a return from
 // exception will go.
-static inline void 
+static inline void
 w_mepc(uint64 x)
 {
   asm volatile("csrw mepc, %0" : : "r" (x));
@@ -56,7 +56,7 @@ r_sstatus()
   return x;
 }
 
-static inline void 
+static inline void
 w_sstatus(uint64 x)
 {
   asm volatile("csrw sstatus, %0" : : "r" (x));
@@ -71,7 +71,7 @@ r_sip()
   return x;
 }
 
-static inline void 
+static inline void
 w_sip(uint64 x)
 {
   asm volatile("csrw sip, %0" : : "r" (x));
@@ -89,7 +89,7 @@ r_sie()
   return x;
 }
 
-static inline void 
+static inline void
 w_sie(uint64 x)
 {
   asm volatile("csrw sie, %0" : : "r" (x));
@@ -107,7 +107,7 @@ r_mie()
   return x;
 }
 
-static inline void 
+static inline void
 w_mie(uint64 x)
 {
   asm volatile("csrw mie, %0" : : "r" (x));
@@ -116,7 +116,7 @@ w_mie(uint64 x)
 // supervisor exception program counter, holds the
 // instruction address to which a return from
 // exception will go.
-static inline void 
+static inline void
 w_sepc(uint64 x)
 {
   asm volatile("csrw sepc, %0" : : "r" (x));
@@ -139,7 +139,7 @@ r_medeleg()
   return x;
 }
 
-static inline void 
+static inline void
 w_medeleg(uint64 x)
 {
   asm volatile("csrw medeleg, %0" : : "r" (x));
@@ -154,7 +154,7 @@ r_mideleg()
   return x;
 }
 
-static inline void 
+static inline void
 w_mideleg(uint64 x)
 {
   asm volatile("csrw mideleg, %0" : : "r" (x));
@@ -162,7 +162,7 @@ w_mideleg(uint64 x)
 
 // Supervisor Trap-Vector Base Address
 // low two bits are mode.
-static inline void 
+static inline void
 w_stvec(uint64 x)
 {
   asm volatile("csrw stvec, %0" : : "r" (x));
@@ -177,7 +177,7 @@ r_stvec()
 }
 
 // Machine-mode interrupt vector
-static inline void 
+static inline void
 w_mtvec(uint64 x)
 {
   asm volatile("csrw mtvec, %0" : : "r" (x));
@@ -203,7 +203,7 @@ w_pmpaddr0(uint64 x)
 
 // supervisor address translation and protection;
 // holds the address of the page table.
-static inline void 
+static inline void
 w_satp(uint64 x)
 {
   asm volatile("csrw satp, %0" : : "r" (x));
@@ -217,7 +217,7 @@ r_satp()
   return x;
 }
 
-static inline void 
+static inline void
 w_mscratch(uint64 x)
 {
   asm volatile("csrw mscratch, %0" : : "r" (x));
@@ -242,7 +242,7 @@ r_stval()
 }
 
 // Machine-mode Counter-Enable
-static inline void 
+static inline void
 w_mcounteren(uint64 x)
 {
   asm volatile("csrw mcounteren, %0" : : "r" (x));
@@ -305,7 +305,7 @@ r_tp()
   return x;
 }
 
-static inline void 
+static inline void
 w_tp(uint64 x)
 {
   asm volatile("mv tp, %0" : : "r" (x));
diff --git a/kernel/sleeplock.c b/kernel/sleeplock.c
index 81de585..a45911e 100644
--- a/kernel/sleeplock.c
+++ b/kernel/sleeplock.c
@@ -44,12 +44,9 @@ int
 holdingsleep(struct sleeplock *lk)
 {
   int r;
-  
+
   acquire(&lk->lk);
   r = lk->locked && (lk->pid == myproc()->pid);
   release(&lk->lk);
   return r;
 }
-
-
-
diff --git a/kernel/sleeplock.h b/kernel/sleeplock.h
index 110e6f3..e389e34 100644
--- a/kernel/sleeplock.h
+++ b/kernel/sleeplock.h
@@ -2,9 +2,8 @@
 struct sleeplock {
   uint locked;       // Is the lock held?
   struct spinlock lk; // spinlock protecting this sleep lock
-  
+
   // For debugging:
   char *name;        // Name of lock.
   int pid;           // Process holding lock
 };
-
diff --git a/kernel/spinlock.h b/kernel/spinlock.h
index 4392820..f8c92cc 100644
--- a/kernel/spinlock.h
+++ b/kernel/spinlock.h
@@ -6,4 +6,3 @@ struct spinlock {
   char *name;        // Name of lock.
   struct cpu *cpu;   // The cpu holding the lock.
 };
-
diff --git a/kernel/string.c b/kernel/string.c
index 153536f..f4f0385 100644
--- a/kernel/string.c
+++ b/kernel/string.c
@@ -35,7 +35,7 @@ memmove(void *dst, const void *src, uint n)
 
   if(n == 0)
     return dst;
-  
+
   s = src;
   d = dst;
   if(s < d && s + n > d){
@@ -104,4 +104,3 @@ strlen(const char *s)
     ;
   return n;
 }
-
diff --git a/kernel/swtch.S b/kernel/swtch.S
index 17a8663..7f97d33 100644
--- a/kernel/swtch.S
+++ b/kernel/swtch.S
@@ -1,8 +1,8 @@
 # Context switch
 #
 #   void swtch(struct context *old, struct context *new);
-# 
-# Save current registers in old. Load from new.	
+#
+# Save current registers in old. Load from new.
 
 
 .globl swtch
@@ -36,7 +36,5 @@ swtch:
         ld s9, 88(a1)
         ld s10, 96(a1)
         ld s11, 104(a1)
-        
-        ret
 
-	
+        ret
diff --git a/kernel/syscall.c b/kernel/syscall.c
index ed65409..cbfdb87 100644
--- a/kernel/syscall.c
+++ b/kernel/syscall.c
@@ -101,6 +101,8 @@ extern uint64 sys_unlink(void);
 extern uint64 sys_link(void);
 extern uint64 sys_mkdir(void);
 extern uint64 sys_close(void);
+extern uint64 sys_settickets(void);
+extern uint64 sys_getpinfo(void);
 
 // An array mapping syscall numbers from syscall.h
 // to the function that handles the system call.
@@ -126,6 +128,8 @@ static uint64 (*syscalls[])(void) = {
 [SYS_link]    sys_link,
 [SYS_mkdir]   sys_mkdir,
 [SYS_close]   sys_close,
+[SYS_settickets]   sys_settickets,
+[SYS_getpinfo]   sys_getpinfo,
 };
 
 void
diff --git a/kernel/syscall.h b/kernel/syscall.h
index bc5f356..bee1422 100644
--- a/kernel/syscall.h
+++ b/kernel/syscall.h
@@ -20,3 +20,5 @@
 #define SYS_link   19
 #define SYS_mkdir  20
 #define SYS_close  21
+#define SYS_settickets  22
+#define SYS_getpinfo  23
\ No newline at end of file
diff --git a/kernel/sysfile.c b/kernel/sysfile.c
index 16b668c..12b0468 100644
--- a/kernel/sysfile.c
+++ b/kernel/sysfile.c
@@ -85,7 +85,7 @@ sys_write(void)
   struct file *f;
   int n;
   uint64 p;
-  
+
   argaddr(1, &p);
   argint(2, &n);
   if(argfd(0, 0, &f) < 0)
@@ -412,7 +412,7 @@ sys_chdir(void)
   char path[MAXPATH];
   struct inode *ip;
   struct proc *p = myproc();
-  
+
   begin_op();
   if(argstr(0, path, MAXPATH) < 0 || (ip = namei(path)) == 0){
     end_op();
diff --git a/kernel/sysproc.c b/kernel/sysproc.c
index 3b4d5bd..2fcff88 100644
--- a/kernel/sysproc.c
+++ b/kernel/sysproc.c
@@ -91,3 +91,69 @@ sys_uptime(void)
   release(&tickslock);
   return xticks;
 }
+
+
+uint64
+sys_settickets(void)
+{
+  extern int LOG_RAW, LOG_PROMO, LOG_DEMO, LOG_BOOST, LOG_LOTTERY;
+  LOG_RAW = 0;
+  LOG_PROMO = 1;
+  LOG_DEMO = 1;
+  LOG_BOOST = 1;
+  LOG_LOTTERY = 1;
+
+
+  struct proc *p = myproc();
+
+  int n;
+
+  // number of tickets to set
+  argint(0,&n);
+
+  int tickets_to_set = n;
+  int return_value = 0;
+
+  if(n<1){
+    tickets_to_set = DEFAULT_TICKETS;
+    return_value = -1;
+  }
+
+  acquire(&p->lock);
+  p->original_tickets = p->current_tickets = tickets_to_set;
+  release(&p->lock);
+
+  return return_value;
+
+}
+
+uint64
+sys_getpinfo(void)
+{
+  extern int LOG_RAW, LOG_PROMO, LOG_DEMO, LOG_BOOST, LOG_LOTTERY;
+  LOG_RAW = 0;
+  LOG_PROMO = 0;
+  LOG_DEMO = 0;
+  LOG_BOOST = 0;
+  LOG_LOTTERY = 0;
+
+  uint64 addr;
+
+  argaddr(0, &addr);
+
+  // validating the argument address passed to kernel
+  if(addr == 0){
+    return -1;
+  }
+
+  int return_value = send_current_pstat(addr);
+
+  LOG_RAW = 0;
+  LOG_PROMO = 1;
+  LOG_DEMO = 1;
+  LOG_BOOST = 1;
+  LOG_LOTTERY = 1;
+
+  return return_value;
+
+}
diff --git a/kernel/trampoline.S b/kernel/trampoline.S
index 693f8a1..76fb881 100644
--- a/kernel/trampoline.S
+++ b/kernel/trampoline.S
@@ -6,7 +6,7 @@
         # at the same virtual address (TRAMPOLINE)
         # in user and kernel space so that it continues
         # to work when it switches page tables.
-        # kernel.ld causes this code to start at 
+        # kernel.ld causes this code to start at
         # a page boundary.
         #
 
@@ -19,7 +19,7 @@
 trampoline:
 .align 4
 .globl uservec
-uservec:    
+uservec:
 	#
         # trap.c sets stvec to point here, so
         # traps from user space start here,
@@ -35,7 +35,7 @@ uservec:
         # but it's mapped to the same virtual address
         # (TRAPFRAME) in every process's user page table.
         li a0, TRAPFRAME
-        
+
         # save the user registers in TRAPFRAME
         sd ra, 40(a0)
         sd sp, 48(a0)
@@ -145,7 +145,7 @@ userret:
 
 	# restore user a0
         ld a0, 112(a0)
-        
+
         # return to user mode and user pc.
         # usertrapret() set up sstatus and sepc.
         sret
diff --git a/kernel/trap.c b/kernel/trap.c
index f21fa26..c325b27 100644
--- a/kernel/trap.c
+++ b/kernel/trap.c
@@ -46,10 +46,10 @@ usertrap(void)
   w_stvec((uint64)kernelvec);
 
   struct proc *p = myproc();
-  
+
   // save user program counter.
   p->trapframe->epc = r_sepc();
-  
+
   if(r_scause() == 8){
     // system call
 
@@ -109,7 +109,7 @@ usertrapret(void)
 
   // set up the registers that trampoline.S's sret will use
   // to get to user space.
-  
+
   // set S Previous Privilege mode to User.
   unsigned long x = r_sstatus();
   x &= ~SSTATUS_SPP; // clear SPP to 0 for user mode
@@ -122,7 +122,7 @@ usertrapret(void)
   // tell trampoline.S the user page table to switch to.
   uint64 satp = MAKE_SATP(p->pagetable);
 
-  // jump to userret in trampoline.S at the top of memory, which 
+  // jump to userret in trampoline.S at the top of memory, which
   // switches to the user page table, restores user registers,
   // and switches to user mode with sret.
   uint64 trampoline_userret = TRAMPOLINE + (userret - trampoline);
@@ -131,14 +131,14 @@ usertrapret(void)
 
 // interrupts and exceptions from kernel code go here via kernelvec,
 // on whatever the current kernel stack is.
-void 
+void
 kerneltrap()
 {
   int which_dev = 0;
   uint64 sepc = r_sepc();
   uint64 sstatus = r_sstatus();
   uint64 scause = r_scause();
-  
+
   if((sstatus & SSTATUS_SPP) == 0)
     panic("kerneltrap: not from supervisor mode");
   if(intr_get() != 0)
@@ -208,7 +208,7 @@ devintr()
     if(cpuid() == 0){
       clockintr();
     }
-    
+
     // acknowledge the software interrupt by clearing
     // the SSIP bit in sip.
     w_sip(r_sip() & ~2);
@@ -218,4 +218,3 @@ devintr()
     return 0;
   }
 }
-
diff --git a/kernel/uart.c b/kernel/uart.c
index e3b3b8a..3843054 100644
--- a/kernel/uart.c
+++ b/kernel/uart.c
@@ -104,7 +104,7 @@ uartputc(int c)
 }
 
 
-// alternate version of uartputc() that doesn't 
+// alternate version of uartputc() that doesn't
 // use interrupts, for use by kernel printf() and
 // to echo characters. it spins waiting for the uart's
 // output register to be empty.
@@ -138,20 +138,20 @@ uartstart()
       // transmit buffer is empty.
       return;
     }
-    
+
     if((ReadReg(LSR) & LSR_TX_IDLE) == 0){
       // the UART transmit holding register is full,
       // so we cannot give it another byte.
       // it will interrupt when it's ready for a new byte.
       return;
     }
-    
+
     int c = uart_tx_buf[uart_tx_r % UART_TX_BUF_SIZE];
     uart_tx_r += 1;
-    
+
     // maybe uartputc() is waiting for space in the buffer.
     wakeup(&uart_tx_r);
-    
+
     WriteReg(THR, c);
   }
 }
diff --git a/kernel/virtio_disk.c b/kernel/virtio_disk.c
index ae6c164..874b409 100644
--- a/kernel/virtio_disk.c
+++ b/kernel/virtio_disk.c
@@ -53,9 +53,9 @@ static struct disk {
   // disk command headers.
   // one-for-one with descriptors, for convenience.
   struct virtio_blk_req ops[NUM];
-  
+
   struct spinlock vdisk_lock;
-  
+
 } disk;
 
 void
@@ -71,7 +71,7 @@ virtio_disk_init(void)
      *R(VIRTIO_MMIO_VENDOR_ID) != 0x554d4551){
     panic("could not find virtio disk");
   }
-  
+
   // reset device
   *R(VIRTIO_MMIO_STATUS) = status;
 
diff --git a/kernel/vm.c b/kernel/vm.c
index 5c31e87..dc6631e 100644
--- a/kernel/vm.c
+++ b/kernel/vm.c
@@ -45,7 +45,7 @@ kvmmake(void)
 
   // allocate and map a kernel stack for each process.
   proc_mapstacks(kpgtbl);
-  
+
   return kpgtbl;
 }
 
@@ -154,7 +154,7 @@ mappages(pagetable_t pagetable, uint64 va, uint64 size, uint64 pa, int perm)
 
   if(size == 0)
     panic("mappages: size");
-  
+
   a = va;
   last = va + size - PGSIZE;
   for(;;){
@@ -345,7 +345,7 @@ void
 uvmclear(pagetable_t pagetable, uint64 va)
 {
   pte_t *pte;
-  
+
   pte = walk(pagetable, va, 0);
   if(pte == 0)
     panic("uvmclear");
diff --git a/mkfs/mkfs.c b/mkfs/mkfs.c
index 1ec326b..670c61f 100644
--- a/mkfs/mkfs.c
+++ b/mkfs/mkfs.c
@@ -134,7 +134,7 @@ main(int argc, char *argv[])
       shortname = argv[i] + 5;
     else
       shortname = argv[i];
-    
+
     assert(index(shortname, '/') == 0);
 
     if((fd = open(argv[i], 0)) < 0)
diff --git a/user/dummyproc.c b/user/dummyproc.c
new file mode 100644
index 0000000..d6aee7b
--- /dev/null
+++ b/user/dummyproc.c
@@ -0,0 +1,56 @@
+#include "kernel/types.h"
+#include "kernel/stat.h"
+#include "user/user.h"
+
+int main(int argc, char *argv[]){
+    if (argc < 3)
+    {
+        fprintf(2, "Usage: %s ticket_number iterations\n", argv[0]);
+        exit(1);
+    }
+
+    int num_tickets = atoi(argv[1]);
+
+    if(settickets(num_tickets) == -1){
+        printf("settickets %s failed\n", argv[1]);
+    }
+
+    int num_iterations = atoi(argv[2]);
+    // int num_iterations = 1000000000;
+
+    int NUM_CHILDREN = 3;
+
+    int indicator;
+
+    // testing forked processes
+    for(int i=0; i<NUM_CHILDREN; i++){
+        indicator = fork();
+        if(indicator == 0){
+            // if it is already a child process, no need to fork from that again
+            break;
+        }
+    }
+
+    int SLEEP_AFTER = num_iterations/10;
+    int SLEEP_FOR = 5;
+
+    // PARENT
+    if(indicator != 0){
+        // in case of parent
+        // do dummy calculation in a continuos loop
+        int a = 0;
+        for(int i=0; i<num_iterations; i++){
+            a = !a; // dummy calculation
+        }
+    } else{
+        // in case of child
+        // do sleep after certain iterations
+        int a = 0;
+        for(int i=0; i<num_iterations; i++){
+            a = !a; // dummy calculation
+            if(i%SLEEP_AFTER == 0){
+                sleep(SLEEP_FOR);
+            }
+        }
+    }
+}
diff --git a/user/grep.c b/user/grep.c
index 6c33766..0f508d0 100644
--- a/user/grep.c
+++ b/user/grep.c
@@ -104,4 +104,3 @@ int matchstar(int c, char *re, char *text)
   }while(*text!='\0' && (*text++==c || c=='.'));
   return 0;
 }
-
diff --git a/user/grind.c b/user/grind.c
index 431ed19..93b5116 100644
--- a/user/grind.c
+++ b/user/grind.c
@@ -61,7 +61,7 @@ go(int which_child)
     exit(1);
   }
   chdir("/");
-  
+
   while(1){
     iters++;
     if((iters % 500) == 0)
@@ -298,7 +298,7 @@ iter()
 {
   unlink("a");
   unlink("b");
-  
+
   int pid1 = fork();
   if(pid1 < 0){
     printf("grind: fork failed\n");
diff --git a/user/testprocinfo.c b/user/testprocinfo.c
new file mode 100644
index 0000000..1f65a0a
--- /dev/null
+++ b/user/testprocinfo.c
@@ -0,0 +1,48 @@
+#include "kernel/types.h"
+#include "kernel/stat.h"
+#include "user/user.h"
+#include "kernel/pstat.h"
+
+#define BLACK_COLOR "\033[30m"
+#define RED_COLOR "\033[31m"
+#define GREEN_COLOR "\033[32m"
+#define YELLOW_COLOR "\033[33m"
+#define BLUE_COLOR "\033[34m"
+#define MAGENTA_COLOR "\033[35m"
+#define CYAN_COLOR "\033[36m"
+#define WHITE_COLOR "\033[37m"
+#define RESET_COLOR "\033[0m"
+
+int main(int argc, char *argv[]){
+    struct pstat curr_stat;
+    if(getpinfo(&curr_stat) == -1){
+        printf("\nSorry! getpinfo syscall failed.\n");
+    }
+
+    printf("\n\n");
+    printf(WHITE_COLOR "|-------|-------|-------|----------------|---------------|----------------------|----------------|---------------|------|-------|\n" RESET_COLOR);
+    printf(WHITE_COLOR "|  PID  | In Use| In Q  |  Waiting time  | Running time  |  # Times Scheduled   |Original Tickets|Current Tickets|  Q0  |  Q1   |\n" RESET_COLOR);
+    printf(WHITE_COLOR "|-------|-------|-------|----------------|---------------|----------------------|----------------|---------------|------|-------|\n" RESET_COLOR);
+
+    for (int i = 0; i < NPROC; i++) {
+        int pid = curr_stat.pid[i];
+        if(pid != 0){
+            printf(WHITE_COLOR "|%d\t| %d\t| %d\t| \t%d\t | \t%d\t |\t%d\t\t| \t%d\t | \t%d\t | %d\t| %d\t|\n" RESET_COLOR,
+               curr_stat.pid[i],
+               curr_stat.inuse[i],
+               curr_stat.inQ[i],
+               curr_stat.waiting_time[i],
+               curr_stat.running_time[i],
+               curr_stat.times_scheduled[i],
+               curr_stat.tickets_original[i],
+               curr_stat.tickets_current[i],
+               curr_stat.queue_ticks[i][0],
+               curr_stat.queue_ticks[i][1]);
+        }
+    }
+
+    printf(WHITE_COLOR "|-------|-------|-------|----------------|---------------|----------------------|----------------|---------------|------|-------|\n" RESET_COLOR);
+    printf("\n\n");
+
+    return 0;
+}
\ No newline at end of file
diff --git a/user/user.h b/user/user.h
index 04013ca..766819e 100644
--- a/user/user.h
+++ b/user/user.h
@@ -1,3 +1,6 @@
+// alternatively, this could have been declared again
+#include "kernel/pstat.h"
+
 struct stat;
 
 // system calls
@@ -22,6 +25,8 @@ int getpid(void);
 char* sbrk(int);
 int sleep(int);
 int uptime(void);
+int settickets(int);
+int getpinfo(struct pstat *);
 
 // ulib.c
 int stat(const char*, struct stat*);
diff --git a/user/user.ld b/user/user.ld
index 0ca922b..20054dc 100644
--- a/user/user.ld
+++ b/user/user.ld
@@ -5,7 +5,7 @@ ENTRY( _main )
 SECTIONS
 {
  . = 0x0;
- 
+
   .text : {
     *(.text .text.*)
   }
diff --git a/user/usertests.c b/user/usertests.c
index 55debe7..72baa9a 100644
--- a/user/usertests.c
+++ b/user/usertests.c
@@ -36,7 +36,7 @@ copyin(char *s)
 
   for(int ai = 0; ai < 2; ai++){
     uint64 addr = addrs[ai];
-    
+
     int fd = open("copyin1", O_CREATE|O_WRONLY);
     if(fd < 0){
       printf("open(copyin1) failed\n");
@@ -49,13 +49,13 @@ copyin(char *s)
     }
     close(fd);
     unlink("copyin1");
-    
+
     n = write(1, (char*)addr, 8192);
     if(n > 0){
       printf("write(1, %p, 8192) returned %d, not -1 or 0\n", (void*)addr, n);
       exit(1);
     }
-    
+
     int fds[2];
     if(pipe(fds) < 0){
       printf("pipe() failed\n");
@@ -141,7 +141,7 @@ copyinstr2(char *s)
   for(int i = 0; i < MAXPATH; i++)
     b[i] = 'x';
   b[MAXPATH] = '\0';
-  
+
   int ret = unlink(b);
   if(ret != -1){
     printf("unlink(%s) returned %d, not -1\n", b, ret);
@@ -244,14 +244,14 @@ void
 rwsbrk()
 {
   int fd, n;
-  
+
   uint64 a = (uint64) sbrk(8192);
 
   if(a == 0xffffffffffffffffLL) {
     printf("sbrk(rwsbrk) failed\n");
     exit(1);
   }
-  
+
   if ((uint64) sbrk(-8192) ==  0xffffffffffffffffLL) {
     printf("sbrk(rwsbrk) shrink failed\n");
     exit(1);
@@ -281,7 +281,7 @@ rwsbrk()
     exit(1);
   }
   close(fd);
-  
+
   exit(0);
 }
 
@@ -290,7 +290,7 @@ void
 truncate1(char *s)
 {
   char buf[32];
-  
+
   unlink("truncfile");
   int fd1 = open("truncfile", O_CREATE|O_WRONLY|O_TRUNC);
   write(fd1, "abcd", 4);
@@ -319,7 +319,7 @@ truncate1(char *s)
     printf("%s: read %d bytes, wanted 0\n", s, n);
     exit(1);
   }
-  
+
   write(fd1, "abcdef", 6);
 
   n = read(fd3, buf, sizeof(buf));
@@ -372,7 +372,7 @@ truncate3(char *s)
   int pid, xstatus;
 
   close(open("truncfile", O_CREATE|O_TRUNC|O_WRONLY));
-  
+
   pid = fork();
   if(pid < 0){
     printf("%s: fork failed\n", s);
@@ -418,7 +418,7 @@ truncate3(char *s)
   unlink("truncfile");
   exit(xstatus);
 }
-  
+
 
 // does chdir() call iput(p->cwd) in a transaction?
 void
@@ -540,7 +540,7 @@ writetest(char *s)
   int fd;
   int i;
   enum { N=100, SZ=10 };
-  
+
   fd = open("small", O_CREATE|O_RDWR);
   if(fd < 0){
     printf("%s: error: creat small failed!\n", s);
@@ -738,7 +738,7 @@ pipe1(char *s)
   int fds[2], pid, xstatus;
   int seq, i, n, cc, total;
   enum { N=5, SZ=1033 };
-  
+
   if(pipe(fds) != 0){
     printf("%s: pipe() failed\n", s);
     exit(1);
@@ -791,7 +791,7 @@ void
 killstatus(char *s)
 {
   int xst;
-  
+
   for(int i = 0; i < 100; i++){
     int pid1 = fork();
     if(pid1 < 0){
@@ -962,7 +962,7 @@ void
 forkfork(char *s)
 {
   enum { N=2 };
-  
+
   for(int i = 0; i < N; i++){
     int pid = fork();
     if(pid < 0){
@@ -1119,7 +1119,7 @@ sharedfd(char *s)
     if(xstatus != 0)
       exit(xstatus);
   }
-  
+
   close(fd);
   fd = open("sharedfd", 0);
   if(fd < 0){
@@ -1154,7 +1154,7 @@ fourfiles(char *s)
   char *names[] = { "f0", "f1", "f2", "f3" };
   char *fname;
   enum { N=12, NCHILD=4, SZ=500 };
-  
+
   for(pi = 0; pi < NCHILD; pi++){
     fname = names[pi];
     unlink(fname);
@@ -2012,11 +2012,11 @@ sbrkbasic(char *s)
       // it's OK if this fails.
       exit(0);
     }
-    
+
     for(b = a; b < a+TOOMUCH; b += 4096){
       *b = 99;
     }
-    
+
     // we should not get here! either sbrk(TOOMUCH)
     // should have failed, or (with lazy allocation)
     // a pagefault should have killed this process.
@@ -2177,7 +2177,7 @@ sbrkfail(char *s)
   char *c, *a;
   int pids[10];
   int pid;
- 
+
   if(pipe(fds) != 0){
     printf("%s: pipe() failed\n", s);
     exit(1);
@@ -2208,7 +2208,7 @@ sbrkfail(char *s)
     exit(1);
   }
 
-  // test running fork with the above allocated page 
+  // test running fork with the above allocated page
   pid = fork();
   if(pid < 0){
     printf("%s: fork failed\n", s);
@@ -2234,7 +2234,7 @@ sbrkfail(char *s)
     exit(1);
 }
 
-  
+
 // test reads/writes from/to allocated memory
 void
 sbrkarg(char *s)
@@ -2260,7 +2260,7 @@ sbrkarg(char *s)
   if(pipe((int *) a) != 0){
     printf("%s: pipe() failed\n", s);
     exit(1);
-  } 
+  }
 }
 
 void
@@ -2318,7 +2318,7 @@ bigargtest(char *s)
     printf("%s: bigargtest: fork failed\n", s);
     exit(1);
   }
-  
+
   wait(&xstatus);
   if(xstatus != 0)
     exit(xstatus);
@@ -2402,7 +2402,7 @@ stacktest(char *s)
 {
   int pid;
   int xstatus;
-  
+
   pid = fork();
   if(pid == 0) {
     char *sp = (char *) r_sp();
@@ -2427,7 +2427,7 @@ textwrite(char *s)
 {
   int pid;
   int xstatus;
-  
+
   pid = fork();
   if(pid == 0) {
     volatile int *addr = (int *) 0;
@@ -2567,7 +2567,7 @@ badarg(char *s)
     argv[1] = 0;
     exec("echo", argv);
   }
-  
+
   exit(0);
 }
 
@@ -2691,7 +2691,7 @@ manywrites(char *s)
 {
   int nchildren = 4;
   int howmany = 30; // increase to look for deadlock
-  
+
   for(int ci = 0; ci < nchildren; ci++){
     int pid = fork();
     if(pid < 0){
@@ -2705,7 +2705,7 @@ manywrites(char *s)
       name[1] = 'a' + ci;
       name[2] = '\0';
       unlink(name);
-      
+
       for(int iters = 0; iters < howmany; iters++){
         for(int i = 0; i < ci+1; i++){
           int fd = open(name, O_CREATE | O_RDWR);
@@ -2747,7 +2747,7 @@ void
 badwrite(char *s)
 {
   int assumed_free = 600;
-  
+
   unlink("junk");
   for(int i = 0; i < assumed_free; i++){
     int fd = open("junk", O_CREATE|O_WRONLY);
@@ -2799,7 +2799,7 @@ execout(char *s)
       // progress.
       for(int i = 0; i < avail; i++)
         sbrk(-4096);
-      
+
       close(1);
       char *args[] = { "echo", "x", 0 };
       exec("echo", args);
@@ -2820,7 +2820,7 @@ diskfull(char *s)
   int done = 0;
 
   unlink("diskfulldir");
-  
+
   for(fi = 0; done == 0 && '0' + fi < 0177; fi++){
     char name[32];
     name[0] = 'b';
@@ -2931,7 +2931,7 @@ struct test slowtests[] = {
   {execout, "execout"},
   {diskfull, "diskfull"},
   {outofinodes, "outofinodes"},
-    
+
   { 0, 0},
 };
 
@@ -2956,7 +2956,7 @@ run(void f(char *), char *s) {
     exit(0);
   } else {
     wait(&xstatus);
-    if(xstatus != 0) 
+    if(xstatus != 0)
       printf("FAILED\n");
     else
       printf("OK\n");
@@ -2995,7 +2995,7 @@ countfree()
     printf("pipe() failed in countfree()\n");
     exit(1);
   }
-  
+
   int pid = fork();
 
   if(pid < 0){
@@ -3005,7 +3005,7 @@ countfree()
 
   if(pid == 0){
     close(fds[0]);
-    
+
     while(1){
       uint64 a = (uint64) sbrk(4096);
       if(a == 0xffffffffffffffff){
@@ -3042,7 +3042,7 @@ countfree()
 
   close(fds[0]);
   wait((int*)0);
-  
+
   return n;
 }
 
diff --git a/user/usys.pl b/user/usys.pl
index 01e426e..873efd6 100755
--- a/user/usys.pl
+++ b/user/usys.pl
@@ -14,7 +14,7 @@ sub entry {
     print " ecall\n";
     print " ret\n";
 }
-	
+
 entry("fork");
 entry("exit");
 entry("wait");
@@ -36,3 +36,5 @@ entry("getpid");
 entry("sbrk");
 entry("sleep");
 entry("uptime");
+entry("settickets");
+entry("getpinfo");
\ No newline at end of file
